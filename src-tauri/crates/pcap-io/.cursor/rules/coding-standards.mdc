---
alwaysApply: true
---
# ä»£ç ç¼–å†™è§„èŒƒå’Œé£æ ¼æ ‡å‡†

## ğŸ¨ å‘½åå’Œé£æ ¼çº¦å®š

### Rust æ ‡å‡†å‘½åè§„èŒƒ

ä¸¥æ ¼éµå¾ª Rust å®˜æ–¹å‘½åçº¦å®šï¼š

```rust
// âœ… ç±»å‹å‘½åï¼šPascalCase
pub struct DataProcessor {}
pub enum ProcessState {}
pub trait Configurable {}

// âœ… å‡½æ•°å’Œå˜é‡ï¼šsnake_case
pub fn process_data() -> Result<()> {}
let file_path = PathBuf::new();
let mut buffer_size = 8192;

// âœ… å¸¸é‡ï¼šUPPER_SNAKE_CASE
pub const DEFAULT_BUFFER_SIZE: usize = 8192;
const MAX_RETRY_ATTEMPTS: u32 = 3;

// âœ… æ¨¡å—ï¼šsnake_case
mod file_processor;
mod data_manager;

// âœ… ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼šå°å†™å­—æ¯
fn process_data<'a>(input: &'a str) -> &'a str {}
```

### å¯è§æ€§æ§åˆ¶åŸåˆ™

ç²¾ç¡®æ§åˆ¶æ¨¡å—å’Œå­—æ®µçš„å¯è§æ€§ï¼š

```rust
// âœ… å…¬å…± API - è°¨æ…æš´éœ²
pub struct PublicService {}        // ç”¨æˆ·ç›´æ¥ä½¿ç”¨
pub fn public_api() -> Result<()> {} // å¯¹å¤–åŠŸèƒ½

// âœ… å†…éƒ¨å®ç° - åˆç†é™åˆ¶
pub(crate) struct InternalHelper {} // å½“å‰ crate å¯è§
pub(super) fn helper_function() {}   // çˆ¶æ¨¡å—å¯è§

// âœ… ç§æœ‰å®ç° - é»˜è®¤éšè—
struct PrivateImpl {}               // ä»…å½“å‰æ¨¡å—
fn internal_logic() {}              // å†…éƒ¨å®ç°

// âœ… å­—æ®µå¯è§æ€§ - ç²¾ç¡®æ§åˆ¶
pub struct ConfiguredService {
    pub name: String,                    // ç”¨æˆ·å¯è®¿é—®
    pub(crate) internal_state: State,   // æ¨¡å—å†…è®¿é—®
    config: ServiceConfig,               // ç§æœ‰é…ç½®
}
```

## ğŸ“ æ³¨é‡Šå’Œæ–‡æ¡£è§„èŒƒ

### ä¸­æ–‡æ–‡æ¡£æ³¨é‡Šæ ‡å‡†

æ‰€æœ‰å…¬å…± API å¿…é¡»æœ‰å®Œæ•´çš„ä¸­æ–‡æ–‡æ¡£ï¼š

````rust
/// é«˜æ€§èƒ½æ•°æ®å¤„ç†å™¨
///
/// æä¾›æ•°æ®çš„è¯»å–ã€å¤„ç†ã€éªŒè¯å’Œè¾“å‡ºåŠŸèƒ½ã€‚æ”¯æŒå¤šç§æ•°æ®æ ¼å¼ï¼Œ
/// å…·å¤‡è‡ªåŠ¨é”™è¯¯æ¢å¤æœºåˆ¶å’Œæ€§èƒ½ä¼˜åŒ–ç­–ç•¥ã€‚
///
/// # ç‰¹æ€§
/// - æ”¯æŒæ‰¹é‡æ“ä½œä»¥æé«˜å¤„ç†æ•ˆç‡
/// - è‡ªåŠ¨èµ„æºç®¡ç†ï¼Œæ— éœ€æ‰‹åŠ¨æ¸…ç†
/// - å¯é…ç½®çš„ç¼“å­˜ç­–ç•¥å’Œè¶…æ—¶æ§åˆ¶
/// - å†…ç½®æ•°æ®éªŒè¯å’Œé”™è¯¯æ¢å¤æœºåˆ¶
///
/// # æ€§èƒ½ç‰¹ç‚¹
/// - é›¶æ‹·è´æ“ä½œå‡å°‘å†…å­˜åˆ†é…
/// - é¢„åˆ†é…ç¼“å†²åŒºé¿å…é¢‘ç¹æ‰©å®¹
/// - æ‰¹é‡å¤„ç†å‡å°‘ç³»ç»Ÿè°ƒç”¨å¼€é”€
///
/// # ç¤ºä¾‹
/// ```rust
/// use my_crate::{DataProcessor, ProcessConfig};
///
/// let config = ProcessConfig::high_performance();
/// let mut processor = DataProcessor::new(config)?;
///
/// let input_data = load_test_data();
/// let result = processor.process_batch(&input_data)?;
///
/// println!("å¤„ç†äº† {} æ¡è®°å½•", result.processed_count);
/// ```
///
/// # é”™è¯¯å¤„ç†
/// æ‰€æœ‰æ–¹æ³•éƒ½è¿”å› `Result` ç±»å‹ï¼Œä¸»è¦é”™è¯¯åŒ…æ‹¬ï¼š
/// - `ProcessError::InvalidInput` - è¾“å…¥æ•°æ®æ ¼å¼æ— æ•ˆ
/// - `ProcessError::ResourceLimit` - è¶…å‡ºèµ„æºé™åˆ¶
/// - `ProcessError::Timeout` - æ“ä½œè¶…æ—¶
pub struct DataProcessor {
    config: ProcessConfig,
    // å…¶ä»–å­—æ®µ...
}

/// å¤„ç†å•æ‰¹æ•°æ®å¹¶è¿”å›å¤„ç†ç»“æœ
///
/// è¯¥æ–¹æ³•ä¼šéªŒè¯è¾“å…¥æ•°æ®æ ¼å¼ï¼Œæ‰§è¡Œé…ç½®çš„å¤„ç†æµç¨‹ï¼Œ
/// å¹¶è¿”å›è¯¦ç»†çš„å¤„ç†ç»Ÿè®¡ä¿¡æ¯ã€‚
///
/// # å‚æ•°
/// * `input_data` - å¾…å¤„ç†çš„è¾“å…¥æ•°æ®åˆ‡ç‰‡ï¼Œä¸ä¼šä¿®æ”¹åŸæ•°æ®
/// * `options` - å¤„ç†é€‰é¡¹ï¼Œè¦†ç›–é»˜è®¤é…ç½®ä¸­çš„ç›¸åº”è®¾ç½®
///
/// # è¿”å›å€¼
/// * `Ok(ProcessResult)` - åŒ…å«å¤„ç†ç»Ÿè®¡å’Œç»“æœæ•°æ®
/// * `Err(ProcessError)` - å¤„ç†è¿‡ç¨‹ä¸­é‡åˆ°çš„é”™è¯¯
///
/// # æ€§èƒ½è¯´æ˜
/// - è¾“å…¥æ•°æ®é€šè¿‡å¼•ç”¨ä¼ é€’ï¼Œé¿å…ä¸å¿…è¦çš„å¤åˆ¶
/// - å†…éƒ¨ä½¿ç”¨æ‰¹é‡å¤„ç†ä»¥æé«˜æ•ˆç‡
/// - é¢„åˆ†é…è¾“å‡ºç¼“å†²åŒºä»¥å‡å°‘å†…å­˜é‡åˆ†é…
///
/// # ç¤ºä¾‹
/// ```rust
/// let options = ProcessOptions::default()
///     .with_validation(true)
///     .with_timeout(Duration::from_secs(30));
///
/// match processor.process_batch(&data, options) {
///     Ok(result) => println!("æˆåŠŸå¤„ç† {} æ¡è®°å½•", result.count),
///     Err(e) => eprintln!("å¤„ç†å¤±è´¥: {}", e),
/// }
/// ```
pub fn process_batch(
    &mut self,
    input_data: &[InputItem],
    options: ProcessOptions
) -> Result<ProcessResult, ProcessError> {
    // å®ç°ç»†èŠ‚...
}
````

### ä»£ç å†…æ³¨é‡Šè§„èŒƒ

ä»£ç å†…ä½¿ç”¨ç®€æ´çš„ä¸­æ–‡æ³¨é‡Šè¯´æ˜å…³é”®é€»è¾‘ï¼š

```rust
impl DataProcessor {
    pub fn new(config: ProcessConfig) -> Result<Self, ProcessError> {
        // éªŒè¯é…ç½®å‚æ•°çš„æœ‰æ•ˆæ€§
        config.validate().map_err(|e| ProcessError::InvalidConfig(e))?;

        // æ ¹æ®é…ç½®åˆ›å»ºå†…éƒ¨ç»„ä»¶
        let cache = if config.enable_cache {
            Some(DataCache::with_capacity(config.cache_size))
        } else {
            None
        };

        // åˆå§‹åŒ–å¤„ç†å™¨çŠ¶æ€
        let processor = Self {
            config,
            cache,
            stats: ProcessStats::new(),
            // é¢„åˆ†é…å·¥ä½œç¼“å†²åŒºä»¥æé«˜æ€§èƒ½
            work_buffer: Vec::with_capacity(config.buffer_size),
        };

        log::info!("æ•°æ®å¤„ç†å™¨åˆå§‹åŒ–å®Œæˆï¼Œé…ç½®: {:?}", processor.config);
        Ok(processor)
    }
}
```

## âš ï¸ é”™è¯¯å¤„ç†è§„èŒƒ

### ç»Ÿä¸€é”™è¯¯ç±»å‹è®¾è®¡

ä½¿ç”¨ `thiserror` åˆ›å»ºæ¸…æ™°çš„é”™è¯¯å±‚æ¬¡ï¼š

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ProcessError {
    #[error("è¾“å…¥æ•°æ®æ— æ•ˆ: {details}")]
    InvalidInput { details: String },

    #[error("é…ç½®é”™è¯¯: {message}")]
    InvalidConfig { message: String },

    #[error("I/O æ“ä½œå¤±è´¥: {source}")]
    IoError {
        #[from]
        source: std::io::Error
    },

    #[error("å¤„ç†è¶…æ—¶ï¼ŒæœŸæœ›åœ¨ {timeout_secs} ç§’å†…å®Œæˆ")]
    Timeout { timeout_secs: u64 },

    #[error("èµ„æºä¸è¶³: {resource} å½“å‰ä½¿ç”¨ {current}ï¼Œé™åˆ¶ {limit}")]
    ResourceLimit {
        resource: String,
        current: usize,
        limit: usize,
    },
}

// é¡¹ç›®ç»Ÿä¸€çš„ Result ç±»å‹
pub type Result<T> = std::result::Result<T, ProcessError>;
```

### åˆ†å±‚é”™è¯¯å¤„ç†ç­–ç•¥

åœ¨ä¸åŒå±‚æ¬¡è¿›è¡Œé€‚å½“çš„é”™è¯¯è½¬æ¢å’Œä¸Šä¸‹æ–‡æ·»åŠ ï¼š

```rust
// æ•°æ®è®¿é—®å±‚ï¼šè½¬æ¢åº•å±‚é”™è¯¯
impl FileReader {
    pub fn read_file<P: AsRef<Path>>(path: P) -> Result<Vec<u8>> {
        std::fs::read(&path).map_err(|io_err| {
            ProcessError::IoError {
                source: io_err
            }
        })
    }
}

// ä¸šåŠ¡é€»è¾‘å±‚ï¼šæ·»åŠ ä¸šåŠ¡ä¸Šä¸‹æ–‡
impl DataProcessor {
    pub fn load_input(&mut self, file_path: &Path) -> Result<InputData> {
        // å°è¯•è¯»å–æ–‡ä»¶
        let raw_data = FileReader::read_file(file_path)
            .map_err(|e| ProcessError::InvalidInput {
                details: format!("æ— æ³•è¯»å–è¾“å…¥æ–‡ä»¶ {:?}: {}", file_path, e)
            })?;

        // è§£ææ•°æ®æ ¼å¼
        InputData::parse(&raw_data)
            .map_err(|parse_err| ProcessError::InvalidInput {
                details: format!("æ–‡ä»¶ {:?} æ ¼å¼è§£æå¤±è´¥: {}", file_path, parse_err)
            })
    }
}

// API å±‚ï¼šæä¾›ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
impl PublicApi {
    pub fn process_file<P: AsRef<Path>>(&mut self, path: P) -> Result<ProcessResult> {
        let path_ref = path.as_ref();

        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if !path_ref.exists() {
            return Err(ProcessError::InvalidInput {
                details: format!("æ–‡ä»¶ä¸å­˜åœ¨: {:?}", path_ref)
            });
        }

        // æ‰§è¡Œå¤„ç†é€»è¾‘
        self.processor.load_input(path_ref)
            .and_then(|input| self.processor.process(input))
            .map_err(|e| {
                log::error!("å¤„ç†æ–‡ä»¶ {:?} å¤±è´¥: {}", path_ref, e);
                e
            })
    }
}
```

### é”™è¯¯æ¢å¤å’Œé™çº§ç­–ç•¥

```rust
impl DataProcessor {
    pub fn process_with_fallback(&mut self, input: InputData) -> Result<ProcessResult> {
        // å°è¯•ä¸»è¦å¤„ç†è·¯å¾„
        match self.process_primary(&input) {
            Ok(result) => Ok(result),
            Err(ProcessError::ResourceLimit { .. }) => {
                // èµ„æºä¸è¶³æ—¶é™çº§åˆ°ç®€åŒ–å¤„ç†
                log::warn!("èµ„æºä¸è¶³ï¼Œåˆ‡æ¢åˆ°ç®€åŒ–å¤„ç†æ¨¡å¼");
                self.process_simplified(&input)
            },
            Err(ProcessError::Timeout { .. }) => {
                // è¶…æ—¶æ—¶å°è¯•éƒ¨åˆ†å¤„ç†
                log::warn!("å¤„ç†è¶…æ—¶ï¼Œå°è¯•éƒ¨åˆ†å¤„ç†");
                self.process_partial(&input)
            },
            Err(other) => Err(other), // å…¶ä»–é”™è¯¯ç›´æ¥è¿”å›
        }
    }
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–è§„èŒƒ

### å†…å­˜ä½¿ç”¨ä¼˜åŒ–

```rust
// âœ… ä¼˜å…ˆä½¿ç”¨å€Ÿç”¨é¿å…ä¸å¿…è¦çš„å…‹éš†
impl DataContainer {
    // è¿”å›å¼•ç”¨è€Œä¸æ˜¯æ‹·è´
    pub fn get_content(&self) -> &[u8] {
        &self.content
    }

    // ä½¿ç”¨ Cow å¤„ç†æ¡ä»¶æ€§ä¿®æ”¹
    pub fn get_processed_content(&self) -> Cow<'_, [u8]> {
        if self.needs_processing() {
            Cow::Owned(self.process_content())
        } else {
            Cow::Borrowed(&self.content)
        }
    }
}

// âœ… é¢„åˆ†é…å®¹å™¨å®¹é‡
pub fn collect_all_data(sources: &[DataSource]) -> Vec<DataItem> {
    // ä¼°ç®—æ€»å®¹é‡é¿å…é‡å¤åˆ†é…
    let estimated_capacity: usize = sources
        .iter()
        .map(|s| s.estimated_item_count())
        .sum();

    let mut items = Vec::with_capacity(estimated_capacity);

    for source in sources {
        items.extend(source.get_items());
    }

    items
}

// âœ… ä½¿ç”¨åˆé€‚çš„å­—ç¬¦ä¸²ç±»å‹
pub fn process_text(input: &str) -> String {  // å‚æ•°ç”¨ &strï¼Œè¿”å› String
    // å¤„ç†é€»è¾‘
    input.to_uppercase()
}
```

### é›¶æ‹·è´æ“ä½œæ¨¡å¼

```rust
// âœ… è®¾è®¡é¿å…ä¸å¿…è¦æ•°æ®æ‹·è´çš„æ¥å£
pub trait ZeroCopyProcessor {
    fn process_in_place(&mut self, data: &mut [u8]) -> Result<usize>;
    fn process_slice(&self, input: &[u8], output: &mut [u8]) -> Result<usize>;
}

// âœ… ä½¿ç”¨å¼•ç”¨é“¾é¿å…ä¸­é—´åˆ†é…
pub fn chain_processors(
    input: &[u8],
    processors: &[Box<dyn ZeroCopyProcessor>]
) -> Result<Vec<u8>> {
    let mut current = input.to_vec(); // åªåœ¨å¼€å§‹æ—¶æ‹·è´ä¸€æ¬¡

    for processor in processors {
        let processed_len = processor.process_in_place(&mut current)?;
        current.truncate(processed_len);
    }

    Ok(current)
}
```

description:
globs:
alwaysApply: false

---
