---
description: å¼€å‘æµç¨‹å’Œå·¥å…·ä½¿ç”¨è§„èŒƒ
alwaysApply: false
---
# å¼€å‘æµç¨‹å’Œå·¥å…·ä½¿ç”¨è§„èŒƒ

## ğŸ”§ å¿…éœ€çš„å¼€å‘å·¥å…·é“¾

### ä»£ç è´¨é‡æ£€æŸ¥å·¥å…·

æ¯æ¬¡æäº¤å‰å¿…é¡»é€šè¿‡ä»¥ä¸‹æ£€æŸ¥ï¼š

```bash
# ä»£ç æ ¼å¼åŒ–ï¼ˆå¿…é¡»ï¼‰
cargo fmt --check

# ä»£ç è´¨é‡æ£€æŸ¥ï¼ˆå¿…é¡»ï¼Œé›¶è­¦å‘Šï¼‰
cargo clippy -- -D warnings

# ç±»å‹æ£€æŸ¥ï¼ˆå¿…é¡»ï¼‰
cargo check --all-targets --all-features

# å•å…ƒæµ‹è¯•ï¼ˆå¿…é¡»å…¨éƒ¨é€šè¿‡ï¼‰
cargo test

# æ–‡æ¡£ç”Ÿæˆæ£€æŸ¥ï¼ˆå¿…é¡»ï¼‰
cargo doc --no-deps --document-private-items
```

### æ¨èçš„è¾…åŠ©å·¥å…·

æå‡å¼€å‘æ•ˆç‡çš„å·¥å…·ï¼š

```bash
# è‡ªåŠ¨ç›‘å¬æ–‡ä»¶å˜åŒ–å¹¶è¿è¡Œæµ‹è¯•
cargo install cargo-watch
cargo watch -x test -x clippy

# æ£€æŸ¥ä¾èµ–çš„å®‰å…¨æ¼æ´
cargo install cargo-audit
cargo audit

# æ£€æŸ¥è¿‡æ—¶çš„ä¾èµ–ç‰ˆæœ¬
cargo install cargo-outdated
cargo outdated

# å±•å¼€å®å®šä¹‰ç”¨äºè°ƒè¯•
cargo install cargo-expand
cargo expand module::macro_name

# æ€§èƒ½åŸºå‡†æµ‹è¯•
cargo install cargo-criterion
cargo criterion
```

## ğŸ“‹ ä»£ç æäº¤å·¥ä½œæµ

### æäº¤å‰æ£€æŸ¥æ¸…å•

ç¡®ä¿æ¯æ¬¡æäº¤éƒ½æ»¡è¶³è´¨é‡æ ‡å‡†ï¼š

```bash
#!/bin/bash
# pre-commit-check.sh

echo "ğŸ” è¿è¡Œä»£ç è´¨é‡æ£€æŸ¥..."

# 1. æ ¼å¼åŒ–æ£€æŸ¥
echo "æ£€æŸ¥ä»£ç æ ¼å¼..."
if ! cargo fmt --check; then
    echo "âŒ ä»£ç æ ¼å¼ä¸è§„èŒƒï¼Œè¯·è¿è¡Œ: cargo fmt"
    exit 1
fi

# 2. Clippy æ£€æŸ¥
echo "è¿è¡Œ Clippy æ£€æŸ¥..."
if ! cargo clippy --all-targets --all-features -- -D warnings; then
    echo "âŒ Clippy æ£€æŸ¥å¤±è´¥ï¼Œè¯·ä¿®å¤è­¦å‘Š"
    exit 1
fi

# 3. æµ‹è¯•æ£€æŸ¥
echo "è¿è¡Œæµ‹è¯•..."
if ! cargo test; then
    echo "âŒ æµ‹è¯•å¤±è´¥ï¼Œè¯·ä¿®å¤æµ‹è¯•"
    exit 1
fi

# 4. æ–‡æ¡£æ£€æŸ¥
echo "æ£€æŸ¥æ–‡æ¡£ç”Ÿæˆ..."
if ! cargo doc --no-deps --document-private-items; then
    echo "âŒ æ–‡æ¡£ç”Ÿæˆå¤±è´¥ï¼Œè¯·ä¿®å¤æ–‡æ¡£æ³¨é‡Š"
    exit 1
fi

echo "âœ… æ‰€æœ‰æ£€æŸ¥é€šè¿‡ï¼Œå¯ä»¥æäº¤ä»£ç "
```

### Git æäº¤ä¿¡æ¯è§„èŒƒ

ä½¿ç”¨è§„èŒƒåŒ–çš„æäº¤ä¿¡æ¯æ ¼å¼ï¼š

```
<ç±»å‹>(<èŒƒå›´>): <ç®€çŸ­æè¿°>

<è¯¦ç»†æè¿°>

<ç ´åæ€§å˜æ›´è¯´æ˜>
<å…³é—­çš„ issue>
```

**ç±»å‹æ ‡è¯†ï¼š**

- `feat`: æ–°åŠŸèƒ½
- `fix`: Bug ä¿®å¤
- `docs`: æ–‡æ¡£æ›´æ–°
- `style`: ä»£ç æ ¼å¼ä¿®æ”¹
- `refactor`: ä»£ç é‡æ„
- `test`: æµ‹è¯•ç›¸å…³
- `chore`: æ„å»ºè¿‡ç¨‹æˆ–è¾…åŠ©å·¥å…·çš„å˜åŠ¨

**ç¤ºä¾‹ï¼š**

```
feat(reader): æ·»åŠ æ‰¹é‡è¯»å– API

- æ–°å¢ read_batch æ–¹æ³•æ”¯æŒæ‰¹é‡è¯»å–æ•°æ®åŒ…
- æä¾›å¯é…ç½®çš„æ‰¹æ¬¡å¤§å°å‚æ•°
- ä¼˜åŒ–å†…å­˜ä½¿ç”¨ï¼Œå‡å°‘å•æ¬¡åˆ†é…å¼€é”€

æ€§èƒ½æå‡: æ‰¹é‡è¯»å–æ¯”å•ä¸ªè¯»å–å¿« 3-5 å€

Closes #123
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥å’Œè§„èŒƒ

### æµ‹è¯•å±‚æ¬¡ç»“æ„

å»ºç«‹å®Œæ•´çš„æµ‹è¯•é‡‘å­—å¡”ï¼š

```rust
// 1. å•å…ƒæµ‹è¯• - æµ‹è¯•å•ä¸ªå‡½æ•°/æ–¹æ³•
#[cfg(test)]
mod unit_tests {
    use super::*;

    #[test]
    fn test_data_validation() {
        let input = create_test_data();
        assert!(validate_data(&input).is_ok());
    }

    #[test]
    fn test_error_handling() {
        let invalid_input = create_invalid_data();
        assert!(matches!(
            validate_data(&invalid_input),
            Err(ValidationError::InvalidFormat { .. })
        ));
    }
}

// 2. é›†æˆæµ‹è¯• - æµ‹è¯•æ¨¡å—é—´äº¤äº’
#[cfg(test)]
mod integration_tests {
    use super::*;

    #[test]
    fn test_full_processing_pipeline() {
        let processor = DataProcessor::new(test_config()).unwrap();
        let input = load_test_dataset();
        let result = processor.process_all(input).unwrap();

        assert_eq!(result.processed_count, input.len());
        assert!(result.errors.is_empty());
    }
}

// 3. æ€§èƒ½æµ‹è¯• - åŸºå‡†æµ‹è¯•å…³é”®è·¯å¾„
#[cfg(test)]
mod bench_tests {
    use super::*;
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    fn benchmark_batch_processing(c: &mut Criterion) {
        let data = generate_test_data(1000);

        c.bench_function("batch_process_1k", |b| {
            b.iter(|| {
                let processor = DataProcessor::new(default_config()).unwrap();
                black_box(processor.process_batch(&data))
            })
        });
    }

    criterion_group!(benches, benchmark_batch_processing);
    criterion_main!(benches);
}
```

### æµ‹è¯•æ•°æ®ç®¡ç†

```rust
// æµ‹è¯•å·¥å…·æ¨¡å—
#[cfg(test)]
pub mod test_utils {
    use super::*;

    /// åˆ›å»ºæ ‡å‡†æµ‹è¯•é…ç½®
    pub fn create_test_config() -> Configuration {
        Configuration {
            buffer_size: 1024,
            enable_validation: true,
            // æµ‹è¯•ç¯å¢ƒçš„ç‰¹æ®Šé…ç½®
            ..Configuration::default()
        }
    }

    /// ç”ŸæˆæŒ‡å®šå¤§å°çš„æµ‹è¯•æ•°æ®
    pub fn generate_test_data(count: usize) -> Vec<TestItem> {
        (0..count)
            .map(|i| TestItem {
                id: i as u64,
                data: format!("test_data_{}", i).into_bytes(),
                timestamp: SystemTime::now(),
            })
            .collect()
    }

    /// åˆ›å»ºä¸´æ—¶æµ‹è¯•ç›®å½•
    pub fn create_temp_dir() -> tempfile::TempDir {
        tempfile::tempdir().expect("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥")
    }
}
```

## ğŸ“Š æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–

### æ€§èƒ½åŸºå‡†æµ‹è¯•

å»ºç«‹æ€§èƒ½åŸºçº¿å’Œå›å½’æ£€æµ‹ï¼š

```rust
// benches/performance.rs
use criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};
use my_crate::*;

fn benchmark_different_sizes(c: &mut Criterion) {
    let mut group = c.benchmark_group("data_processing");

    // æµ‹è¯•ä¸åŒæ•°æ®å¤§å°çš„æ€§èƒ½
    for size in [100, 1000, 10000].iter() {
        group.bench_with_input(
            BenchmarkId::new("process_data", size),
            size,
            |b, &size| {
                let data = generate_test_data(size);
                b.iter(|| process_data(&data))
            },
        );
    }
    group.finish();
}

criterion_group!(benches, benchmark_different_sizes);
criterion_main!(benches);
```

### å†…å­˜ä½¿ç”¨ç›‘æ§

```rust
#[cfg(test)]
mod memory_tests {
    use super::*;

    #[test]
    fn test_memory_usage() {
        let initial_memory = get_memory_usage();

        {
            let processor = DataProcessor::new(default_config()).unwrap();
            let large_data = generate_large_test_data();
            let _result = processor.process_all(large_data).unwrap();
        } // processor åœ¨æ­¤å¤„ææ„

        // å¼ºåˆ¶åƒåœ¾å›æ”¶
        std::thread::sleep(Duration::from_millis(100));

        let final_memory = get_memory_usage();
        let memory_leak = final_memory - initial_memory;

        // å…è®¸å°‘é‡å†…å­˜å¢é•¿ï¼Œä½†ä¸åº”æœ‰æ˜æ˜¾æ³„æ¼
        assert!(memory_leak < 1024 * 1024, "å¯èƒ½å­˜åœ¨å†…å­˜æ³„æ¼: {} bytes", memory_leak);
    }
}
```

## ğŸ“š æ–‡æ¡£ç»´æŠ¤è§„èŒƒ

### API æ–‡æ¡£è¦æ±‚

æ‰€æœ‰å…¬å…±æ¥å£å¿…é¡»æœ‰å®Œæ•´æ–‡æ¡£ï¼š

````rust
/// æ¨¡å—çº§æ–‡æ¡£
///
/// è¿™ä¸ªæ¨¡å—æä¾›æ•°æ®å¤„ç†çš„æ ¸å¿ƒåŠŸèƒ½ï¼ŒåŒ…æ‹¬ï¼š
/// - æ•°æ®éªŒè¯å’Œæ ¼å¼åŒ–
/// - æ‰¹é‡å¤„ç†å’Œæ€§èƒ½ä¼˜åŒ–
/// - é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
///
/// # ä½¿ç”¨ç¤ºä¾‹
/// ```rust
/// use my_crate::processor::*;
///
/// let config = ProcessorConfig::default();
/// let processor = DataProcessor::new(config)?;
/// let result = processor.process(&input_data)?;
/// ```

// ä¸ºå¤æ‚ç®—æ³•æä¾›è¯¦ç»†è¯´æ˜
impl DataProcessor {
    /// ä½¿ç”¨ä¼˜åŒ–çš„æ‰¹é‡å¤„ç†ç®—æ³•
    ///
    /// # ç®—æ³•è¯´æ˜
    /// 1. å°†è¾“å…¥æ•°æ®æŒ‰é…ç½®çš„æ‰¹æ¬¡å¤§å°åˆ†ç»„
    /// 2. å¹¶è¡Œå¤„ç†æ¯ä¸ªæ‰¹æ¬¡ä»¥æé«˜æ•ˆç‡
    /// 3. åˆå¹¶ç»“æœå¹¶è¿›è¡Œæœ€ç»ˆéªŒè¯
    ///
    /// # æ—¶é—´å¤æ‚åº¦
    /// O(n) å…¶ä¸­ n æ˜¯è¾“å…¥æ•°æ®çš„æ€»æ•°é‡
    ///
    /// # å†…å­˜å¤æ‚åº¦
    /// O(batch_size) æ¯ä¸ªæ‰¹æ¬¡çš„å†…å­˜ä½¿ç”¨é‡
    pub fn process_optimized(&mut self, data: &[InputItem]) -> Result<ProcessResult> {
        // å®ç°ç»†èŠ‚...
    }
}
````

### ç¤ºä¾‹ä»£ç è¦æ±‚

```rust
// examples/basic_usage.rs
//! åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹
//!
//! æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œæ•°æ®å¤„ç†

use my_crate::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. åˆ›å»ºé…ç½®
    let config = Configuration::default()
        .with_buffer_size(8192)
        .with_validation(true);

    // 2. åˆå§‹åŒ–å¤„ç†å™¨
    let mut processor = DataProcessor::new(config)?;

    // 3. åŠ è½½æµ‹è¯•æ•°æ®
    let input_data = load_sample_data()?;

    // 4. æ‰§è¡Œå¤„ç†
    let result = processor.process_batch(&input_data)?;

    // 5. è¾“å‡ºç»“æœ
    println!("å¤„ç†å®Œæˆ:");
    println!("  è¾“å…¥æ•°æ®: {} æ¡", input_data.len());
    println!("  å¤„ç†æˆåŠŸ: {} æ¡", result.success_count);
    println!("  å¤„ç†å¤±è´¥: {} æ¡", result.error_count);

    Ok(())
}

fn load_sample_data() -> Result<Vec<InputItem>, std::io::Error> {
    // ç¤ºä¾‹æ•°æ®åŠ è½½é€»è¾‘
    Ok(vec![
        InputItem::new("sample1", b"data1".to_vec()),
        InputItem::new("sample2", b"data2".to_vec()),
    ])
}
```

## ğŸ”„ æŒç»­é›†æˆé…ç½®

### GitHub Actions å·¥ä½œæµ

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
          components: rustfmt, clippy

      - name: Check formatting
        run: cargo fmt --all -- --check

      - name: Run clippy
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Run tests
        run: cargo test --all-features

      - name: Run benchmarks
        run: cargo bench --no-run

      - name: Check documentation
        run: cargo doc --no-deps --all-features
```
