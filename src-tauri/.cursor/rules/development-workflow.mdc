---
description: å¼€å‘æµç¨‹å’Œå·¥å…·ä½¿ç”¨è§„èŒƒ
alwaysApply: false
---
# å¼€å‘æµç¨‹å’Œå·¥å…·ä½¿ç”¨è§„èŒƒ

## ğŸ”§ Rust å¼€å‘å·¥å…·é“¾

### å¿…éœ€å·¥å…·å®‰è£…

```bash
# Rust å·¥å…·é“¾
rustup update stable
rustup component add rustfmt clippy rust-src

# Tauri CLI å·¥å…·
cargo install tauri-cli
cargo install --locked trunk  # å¦‚éœ€WebAssemblyæ”¯æŒ

# ä»£ç è´¨é‡å·¥å…·
cargo install cargo-watch     # æ–‡ä»¶å˜åŒ–ç›‘å¬
cargo install cargo-audit     # å®‰å…¨æ¼æ´æ£€æŸ¥
cargo install cargo-machete   # æœªä½¿ç”¨ä¾èµ–æ£€æŸ¥
cargo install cargo-outdated  # è¿‡æœŸä¾èµ–æ£€æŸ¥
cargo install cargo-expand    # å®å±•å¼€å·¥å…·
```

## ğŸ“‹ å¼€å‘å·¥ä½œæµ

### ä»£ç æäº¤å‰æ£€æŸ¥

```bash
#!/bin/bash
# scripts/pre-commit-check.sh

echo "ğŸ” è¿è¡Œ Tauri åç«¯ä»£ç è´¨é‡æ£€æŸ¥..."

# 1. Rustä»£ç æ ¼å¼åŒ–æ£€æŸ¥
echo "æ£€æŸ¥ä»£ç æ ¼å¼..."
if ! cargo fmt --all -- --check; then
    echo "âŒ ä»£ç æ ¼å¼ä¸è§„èŒƒï¼Œè¿è¡Œä¿®å¤: cargo fmt"
    exit 1
fi

# 2. Clippyé™æ€åˆ†æ
echo "è¿è¡Œ Clippy æ£€æŸ¥..."
if ! cargo clippy --all-targets --all-features --workspace -- -D warnings; then
    echo "âŒ Clippy æ£€æŸ¥å¤±è´¥ï¼Œè¯·ä¿®å¤è­¦å‘Š"
    exit 1
fi

# 3. ç±»å‹æ£€æŸ¥
echo "è¿è¡Œç±»å‹æ£€æŸ¥..."
if ! cargo check --all-targets --all-features --workspace; then
    echo "âŒ ç±»å‹æ£€æŸ¥å¤±è´¥"
    exit 1
fi

# 4. å•å…ƒæµ‹è¯•
echo "è¿è¡Œå•å…ƒæµ‹è¯•..."
if ! cargo test --workspace; then
    echo "âŒ æµ‹è¯•å¤±è´¥ï¼Œè¯·ä¿®å¤æµ‹è¯•"
    exit 1
fi

# 5. æ–‡æ¡£ç”Ÿæˆæ£€æŸ¥
echo "æ£€æŸ¥æ–‡æ¡£ç”Ÿæˆ..."
if ! cargo doc --no-deps --workspace; then
    echo "âŒ æ–‡æ¡£ç”Ÿæˆå¤±è´¥ï¼Œè¯·ä¿®å¤æ–‡æ¡£æ³¨é‡Š"
    exit 1
fi

# 6. å®‰å…¨æ¼æ´æ£€æŸ¥
echo "æ£€æŸ¥å®‰å…¨æ¼æ´..."
if ! cargo audit; then
    echo "âš ï¸ å‘ç°å®‰å…¨æ¼æ´ï¼Œè¯·æ›´æ–°ä¾èµ–"
fi

echo "âœ… æ‰€æœ‰æ£€æŸ¥é€šè¿‡ï¼Œå¯ä»¥æäº¤ä»£ç "
```

### Tauri ä¸“ç”¨å¼€å‘è„šæœ¬

```json
// package.json (å¦‚æœéœ€è¦ä¸å‰ç«¯åä½œ)
{
  "scripts": {
    "tauri:dev": "cargo tauri dev",
    "tauri:build": "cargo tauri build",
    "tauri:test": "cd src-tauri && cargo test",
    "tauri:check": "cd src-tauri && cargo check",
    "tauri:clippy": "cd src-tauri && cargo clippy -- -D warnings",
    "tauri:fmt": "cd src-tauri && cargo fmt",
    "tauri:doc": "cd src-tauri && cargo doc --open"
  }
}
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### æµ‹è¯•åˆ†ç±»å’Œç»“æ„

```rust
// tests/integration_tests.rs - é›†æˆæµ‹è¯•
use tempfile::TempDir;
use playback_engine_lib::{ProjectManager, types::ProjectInfo};

#[tokio::test]
async fn test_project_lifecycle() {
    // åˆ›å»ºä¸´æ—¶æµ‹è¯•ç›®å½•
    let temp_dir = TempDir::new().unwrap();
    let project_path = temp_dir.path().join("test_project");

    // æµ‹è¯•é¡¹ç›®åˆ›å»ºå’ŒåŠ è½½
    let mut manager = ProjectManager::new();

    // åˆ›å»ºæµ‹è¯•é¡¹ç›®
    create_test_project(&project_path).await.unwrap();

    // æµ‹è¯•æ‰“å¼€é¡¹ç›®
    let project_info = manager.open_project(&project_path).await.unwrap();
    assert_eq!(project_info.name, "test_project");

    // æµ‹è¯•é¡¹ç›®ä¿¡æ¯è·å–
    let current_project = manager.get_current_project();
    assert!(current_project.is_some());
}

#[tokio::test]
async fn test_pcap_processing() {
    let temp_dir = TempDir::new().unwrap();
    let dataset_path = temp_dir.path().join("test_dataset");

    // æµ‹è¯•PCAPæ•°æ®å¤„ç†æµç¨‹
    let config = pcapfile_io::Configuration::default();
    let mut writer = pcapfile_io::Writer::new(&dataset_path, "test", config.clone()).unwrap();

    // å†™å…¥æµ‹è¯•æ•°æ®
    for i in 0..100 {
        let packet = create_test_packet(i);
        writer.write_packet(&packet).unwrap();
    }
    writer.finalize().unwrap();

    // è¯»å–å¹¶éªŒè¯æ•°æ®
    let mut reader = pcapfile_io::Reader::new(&dataset_path, config).unwrap();
    let mut count = 0;
    while let Some(_packet) = reader.read_packet().unwrap() {
        count += 1;
    }
    assert_eq!(count, 100);
}

// src/lib.rs - å•å…ƒæµ‹è¯•
#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::DatasetConfig;

    #[test]
    fn test_dataset_config_validation() {
        let config = DatasetConfig {
            name: "test_dataset".to_string(),
            dataset_type: crate::types::DatasetType::Environment,
            pcap_files: vec![PathBuf::from("test.pcap")],
            config: pcapfile_io::Configuration::default(),
        };

        assert!(validate_dataset_config(&config).is_ok());
    }

    #[tokio::test]
    async fn test_project_manager_state() {
        let mut manager = ProjectManager::new();

        // æµ‹è¯•åˆå§‹çŠ¶æ€
        assert!(manager.get_current_project().is_none());
        assert!(manager.list_dataset_names().is_empty());

        // æµ‹è¯•çŠ¶æ€å˜æ›´
        // ...
    }
}
```

### æ€§èƒ½æµ‹è¯•

```rust
// benches/command_performance.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use playback_engine_lib::{ProjectManager, types::ProjectInfo};
use tempfile::TempDir;

fn benchmark_project_loading(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();

    let mut group = c.benchmark_group("project_operations");

    // æµ‹è¯•ä¸åŒå¤§å°çš„é¡¹ç›®åŠ è½½æ€§èƒ½
    for size in [10, 100, 1000].iter() {
        group.bench_with_input(
            BenchmarkId::new("load_project", size),
            size,
            |b, &size| {
                b.to_async(&rt).iter(|| async {
                    let temp_dir = TempDir::new().unwrap();
                    let project_path = create_test_project_with_datasets(&temp_dir, size).await;

                    let mut manager = ProjectManager::new();
                    black_box(manager.open_project(&project_path).await.unwrap())
                });
            },
        );
    }
    group.finish();
}

fn benchmark_pcap_processing(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();

    c.bench_function("pcap_read_1k_packets", |b| {
        b.to_async(&rt).iter(|| async {
            let dataset_path = create_test_dataset(1000).await;
            let config = pcapfile_io::Configuration::default();
            let mut reader = pcapfile_io::Reader::new(&dataset_path, config).unwrap();

            let mut count = 0;
            while let Some(_packet) = reader.read_packet().unwrap() {
                count += 1;
            }
            black_box(count)
        });
    });
}

criterion_group!(benches, benchmark_project_loading, benchmark_pcap_processing);
criterion_main!(benches);
```

## ğŸš€ æ„å»ºå’Œéƒ¨ç½²

### å¼€å‘æ¨¡å¼å¯åŠ¨

```bash
# æ–¹å¼1: ä½¿ç”¨Tauri CLI (æ¨è)
cargo tauri dev

# æ–¹å¼2: å•ç‹¬å¯åŠ¨åç«¯è¿›è¡Œè°ƒè¯•
RUST_LOG=debug cargo run

# æ–¹å¼3: ç›‘å¬æ–‡ä»¶å˜åŒ–è‡ªåŠ¨é‡å¯
cargo watch -x 'run' -w src/ -w crates/

# æ–¹å¼4: è°ƒè¯•æ¨¡å¼å¯åŠ¨
RUST_LOG=trace RUST_BACKTRACE=full cargo tauri dev
```

### ç”Ÿäº§æ„å»º

```bash
# å®Œæ•´æ„å»ºæ‰€æœ‰ç›®æ ‡å¹³å°
cargo tauri build

# æŒ‡å®šç›®æ ‡å¹³å°æ„å»º
cargo tauri build --target x86_64-unknown-linux-gnu
cargo tauri build --target x86_64-pc-windows-msvc

# Releaseæ¨¡å¼ä¼˜åŒ–æ„å»º
RUSTFLAGS="-C target-cpu=native" cargo tauri build --release

# ç”Ÿæˆè°ƒè¯•ä¿¡æ¯çš„Releaseæ„å»º
cargo tauri build --release --config '{"tauri":{"bundle":{"active":false}}}'
```

### æ„å»ºä¼˜åŒ–è®¾ç½®

```toml
# Cargo.toml
[profile.release]
opt-level = 3
lto = true
codegen-units = 1
panic = "abort"

[profile.dev]
opt-level = 0
debug = true
split-debuginfo = "unpacked"

[profile.test]
opt-level = 1
debug = true

# é’ˆå¯¹ä¾èµ–åº“çš„ä¼˜åŒ–
[profile.dev.package."*"]
opt-level = 2
```

## ğŸ“Š è°ƒè¯•å’Œè¯Šæ–­

### æ—¥å¿—é…ç½®å’Œä½¿ç”¨

```rust
// src/main.rs
use log::{info, warn, error, debug, trace};

fn init_logging() {
    let env = env_logger::Env::default()
        .filter_or("RUST_LOG", "info,playback_engine=debug,pcapfile_io=debug");

    env_logger::Builder::from_env(env)
        .format_timestamp(Some(env_logger::fmt::TimestampPrecision::Millis))
        .format_module_path(true)
        .format_target(false)
        .init();

    info!("æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
}

// åœ¨ä»£ç ä¸­ä½¿ç”¨æ—¥å¿—
#[tauri::command]
pub async fn debug_command(param: String) -> Result<String, String> {
    debug!("æ¥æ”¶åˆ°è°ƒè¯•å‘½ä»¤ï¼Œå‚æ•°: {}", param);

    // æ€§èƒ½æ•æ„Ÿçš„æ“ä½œä½¿ç”¨traceçº§åˆ«
    trace!("å¼€å§‹æ‰§è¡Œè¯¦ç»†æ­¥éª¤...");

    match perform_operation(&param).await {
        Ok(result) => {
            info!("æ“ä½œæˆåŠŸå®Œæˆ: {}", result);
            Ok(result)
        }
        Err(e) => {
            error!("æ“ä½œå¤±è´¥: {}", e);
            Err(e.to_string())
        }
    }
}
```

### æ€§èƒ½åˆ†æå·¥å…·

```bash
# CPUæ€§èƒ½åˆ†æ
cargo install flamegraph
CARGO_PROFILE_RELEASE_DEBUG=true cargo flamegraph --bin playback-engine

# å†…å­˜ä½¿ç”¨åˆ†æ
cargo install heaptrack
heaptrack cargo run --release

# åŸºå‡†æµ‹è¯•
cargo bench
cargo bench -- --output-format html

# ä¾èµ–åˆ†æ
cargo tree
cargo machete
cargo outdated
```

### å¸¸è§é—®é¢˜è¯Šæ–­

```bash
# ç¼–è¯‘é—®é¢˜è¯Šæ–­
RUST_LOG=cargo::core::compiler cargo build -v

# ä¾èµ–é—®é¢˜è§£å†³
cargo clean
cargo update
cargo check

# Tauriç‰¹å®šé—®é¢˜
cargo tauri info  # æŸ¥çœ‹ç¯å¢ƒä¿¡æ¯
cargo tauri dev --verbose  # è¯¦ç»†è°ƒè¯•ä¿¡æ¯

# PCAPå¤„ç†é—®é¢˜
RUST_LOG=pcapfile_io=trace cargo test pcap_tests -- --nocapture
```

## ğŸ“š æ–‡æ¡£å’Œç»´æŠ¤

### APIæ–‡æ¡£ç”Ÿæˆ

```bash
# ç”Ÿæˆå®Œæ•´æ–‡æ¡£
cargo doc --no-deps --workspace --open

# åŒ…å«ç§æœ‰é¡¹çš„æ–‡æ¡£
cargo doc --document-private-items --workspace

# æ£€æŸ¥æ–‡æ¡£é“¾æ¥
cargo doc --workspace 2>&1 | grep "warning: "
```

### ä»£ç è¦†ç›–ç‡

```bash
# å®‰è£…è¦†ç›–ç‡å·¥å…·
cargo install cargo-tarpaulin

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
cargo tarpaulin --out Html --output-dir coverage/

# ä¸Šä¼ åˆ°codecov (CIç¯å¢ƒ)
cargo tarpaulin --out Xml
bash <(curl -s https://codecov.io/bash)
```

### ä¾èµ–ç®¡ç†

```bash
# æ£€æŸ¥è¿‡æœŸä¾èµ–
cargo outdated

# æ›´æ–°ä¾èµ–
cargo update

# æ£€æŸ¥æœªä½¿ç”¨çš„ä¾èµ–
cargo machete

# å®‰å…¨å®¡è®¡
cargo audit

# è®¸å¯è¯æ£€æŸ¥
cargo install cargo-license
cargo license
```
