---
alwaysApply: true
---
# ä»£ç é£æ ¼å’Œå·¥ç¨‹å¼€å‘è§„èŒƒ

## ğŸ¦€ Rust ä»£ç è§„èŒƒ

### å‘½åçº¦å®š

```rust
// âœ… ç»“æ„ä½“å’Œæšä¸¾ï¼šPascalCase
pub struct ProjectManager {}
pub struct DatasetInfo {}
pub enum PlaybackState { Playing, Paused, Stopped }
pub enum PacketType { Environment, Event, Target, Unknown }

// âœ… å‡½æ•°å’Œå˜é‡ï¼šsnake_case
pub async fn load_project_data() -> Result<ProjectInfo> {}
pub fn process_pcap_file() -> Result<()> {}
let project_path = PathBuf::new();
let dataset_config = DatasetConfig::default();

// âœ… å¸¸é‡ï¼šUPPER_SNAKE_CASE
pub const MAX_PACKET_SIZE: usize = 65536;
pub const DEFAULT_TIMEOUT_SECS: u64 = 30;
const PCAP_MAGIC_NUMBER: u32 = 0xA1B2C3D4;

// âœ… æ¨¡å—ï¼šsnake_case
mod project_manager;
mod dataset_processor;
mod pcap_utils;
```

### Tauri å‘½ä»¤è§„èŒƒ

```rust
/// å·¥ç¨‹ç®¡ç†ç›¸å…³å‘½ä»¤
///
/// è´Ÿè´£å¤„ç†é¡¹ç›®çš„æ‰“å¼€ã€å…³é—­å’Œä¿¡æ¯è·å–æ“ä½œ
#[tauri::command]
pub async fn open_project(
    app: AppHandle,
    project_path: String,
) -> std::result::Result<ProjectInfo, String> {
    info!("æ¥æ”¶åˆ°æ‰“å¼€é¡¹ç›®è¯·æ±‚: {}", project_path);

    // 1. å‚æ•°éªŒè¯
    if project_path.is_empty() {
        return Err("é¡¹ç›®è·¯å¾„ä¸èƒ½ä¸ºç©º".to_string());
    }

    // 2. è·å–çŠ¶æ€ç®¡ç†å™¨
    let project_manager_state = app.state::<std::sync::Mutex<ProjectManager>>();
    let mut manager = project_manager_state.lock().unwrap();

    // 3. æ‰§è¡Œæ ¸å¿ƒé€»è¾‘
    match manager.open_project(&project_path).await {
        Ok(project_info) => {
            info!("é¡¹ç›®æ‰“å¼€æˆåŠŸ: {}", project_info.name);
            Ok(project_info)
        }
        Err(e) => {
            error!("é¡¹ç›®æ‰“å¼€å¤±è´¥: {}", e);
            Err(e.to_string())
        }
    }
}

/// æ•°æ®é›†æ“ä½œå‘½ä»¤æ¨¡æ¿
#[tauri::command]
pub async fn process_dataset(
    app: AppHandle,
    dataset_name: String,
    options: ProcessOptions,
) -> std::result::Result<ProcessResult, String> {
    // éµå¾ªç»Ÿä¸€çš„å‘½ä»¤å¤„ç†æ¨¡å¼
    validate_params(&dataset_name, &options)?;

    let state = app.state::<AppState>();
    execute_dataset_processing(state, dataset_name, options)
        .await
        .map_err(|e| e.to_string())
}
```

### é”™è¯¯å¤„ç†è§„èŒƒ

```rust
use thiserror::Error;

/// åº”ç”¨ç»Ÿä¸€é”™è¯¯ç±»å‹
#[derive(Error, Debug)]
pub enum PlaybackError {
    #[error("é¡¹ç›®æ“ä½œé”™è¯¯: {message}")]
    ProjectError { message: String },

    #[error("æ•°æ®é›†å¤„ç†é”™è¯¯: {dataset} - {source}")]
    DatasetError {
        dataset: String,
        #[from]
        source: pcap_io::PcapError,
    },

    #[error("I/Oæ“ä½œå¤±è´¥: {operation} - {source}")]
    IoError {
        operation: String,
        #[from]
        source: std::io::Error,
    },

    #[error("é…ç½®é”™è¯¯: {config_key} = {config_value}")]
    ConfigError {
        config_key: String,
        config_value: String,
    },

    #[error("æ’­æ”¾æ§åˆ¶é”™è¯¯: {reason}")]
    PlaybackControlError { reason: String },
}

/// é¡¹ç›®ç»Ÿä¸€çš„ Result ç±»å‹
pub type Result<T> = std::result::Result<T, PlaybackError>;

/// é”™è¯¯å¤„ç†è¾…åŠ©å‡½æ•°
pub fn handle_pcap_error(
    operation: &str,
    result: pcap_io::Result<impl std::fmt::Debug>,
) -> Result<()> {
    result.map_err(|e| PlaybackError::DatasetError {
        dataset: operation.to_string(),
        source: e,
    })?;
    Ok(())
}
```

### å¼‚æ­¥ç¼–ç¨‹è§„èŒƒ

```rust
/// CPUå¯†é›†å‹ä»»åŠ¡å¤„ç†
#[tauri::command]
pub async fn analyze_large_dataset(
    dataset_path: String,
    analysis_options: AnalysisOptions,
) -> Result<AnalysisResult, String> {
    tokio::task::spawn_blocking(move || {
        // åœ¨çº¿ç¨‹æ± ä¸­æ‰§è¡ŒCPUå¯†é›†å‹ä»»åŠ¡
        perform_dataset_analysis(&dataset_path, &analysis_options)
    })
    .await
    .map_err(|e| format!("åˆ†æä»»åŠ¡æ‰§è¡Œå¤±è´¥: {}", e))?
    .map_err(|e| e.to_string())
}

/// I/Oå¯†é›†å‹ä»»åŠ¡å¤„ç†
#[tauri::command]
pub async fn load_project_metadata(
    project_path: String,
) -> Result<ProjectMetadata, String> {
    // å¼‚æ­¥æ–‡ä»¶è¯»å–
    let content = tokio::fs::read_to_string(&project_path)
        .await
        .map_err(|e| format!("è¯»å–é¡¹ç›®æ–‡ä»¶å¤±è´¥: {}", e))?;

    // å¼‚æ­¥è§£æ
    parse_project_metadata(&content)
        .await
        .map_err(|e| e.to_string())
}

/// çŠ¶æ€ç®¡ç†æœ€ä½³å®è·µ
pub struct AppState {
    project_manager: Arc<Mutex<ProjectManager>>,
    playback_controller: Arc<Mutex<PlaybackController>>,
    app_config: Arc<RwLock<AppConfig>>,
}

impl AppState {
    /// å®‰å…¨çš„çŠ¶æ€è®¿é—®
    pub async fn with_project_manager<F, R>(&self, f: F) -> R
    where
        F: FnOnce(&mut ProjectManager) -> R,
    {
        let mut manager = self.project_manager.lock().unwrap();
        f(&mut manager)
    }

    /// è¯»å–é…ç½®ï¼ˆæ— é”å†²çªï¼‰
    pub fn get_config_value(&self, key: &str) -> Option<String> {
        let config = self.app_config.read().unwrap();
        config.get(key).cloned()
    }
}
```

### ç±»å‹å®šä¹‰è§„èŒƒ

```rust
/// ç±»å‹å®šä¹‰ä½¿ç”¨å……åˆ†çš„æ–‡æ¡£æ³¨é‡Š
///
/// é¡¹ç›®ä¿¡æ¯ç»“æ„ä½“ï¼ŒåŒ…å«é¡¹ç›®çš„åŸºæœ¬å…ƒæ•°æ®å’Œç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectInfo {
    /// é¡¹ç›®åç§°
    pub name: String,
    /// é¡¹ç›®è·¯å¾„
    pub path: PathBuf,
    /// é¡¹ç›®åˆ›å»ºæ—¶é—´
    pub created_at: chrono::DateTime<chrono::Utc>,
    /// åŒ…å«çš„æ•°æ®é›†åˆ—è¡¨
    pub datasets: Vec<DatasetConfig>,
    /// é¡¹ç›®æ€»æ•°æ®åŒ…æ•°é‡
    pub total_packets: u64,
    /// é¡¹ç›®æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    pub total_size: u64,
}

/// æ•°æ®é›†é…ç½®ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatasetConfig {
    /// æ•°æ®é›†åç§°
    pub name: String,
    /// æ•°æ®é›†ç±»å‹
    pub dataset_type: DatasetType,
    /// PCAPæ–‡ä»¶è·¯å¾„åˆ—è¡¨
    pub pcap_files: Vec<PathBuf>,
    /// æ•°æ®é›†é…ç½®å‚æ•°
    pub config: pcap_io::Configuration,
}

/// æ•°æ®é›†ç±»å‹æšä¸¾
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DatasetType {
    /// ç¯å¢ƒæ•°æ®é›†
    Environment,
    /// äº‹ä»¶æ•°æ®é›†
    Event,
    /// ç›®æ ‡æ•°æ®é›†
    Target,
    /// æ··åˆæ•°æ®é›†
    Mixed,
}
```

## ğŸ“ æ–‡æ¡£æ³¨é‡Šè§„èŒƒ

### æ¨¡å—çº§æ–‡æ¡£

```rust
//! # å·¥ç¨‹ç®¡ç†æ¨¡å—
//!
//! æä¾›é¡¹ç›®çš„åŠ è½½ã€ä¿å­˜ã€é…ç½®ç®¡ç†ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚
//! æ”¯æŒå¤šç§é¡¹ç›®æ ¼å¼ï¼Œæä¾›å¼‚æ­¥æ“ä½œæ¥å£ã€‚
//!
//! ## ä¸»è¦åŠŸèƒ½
//!
//! - é¡¹ç›®ç›®å½•æ‰«æå’ŒéªŒè¯
//! - PPROJæ ¼å¼æ–‡ä»¶çš„è¯»å†™
//! - æ•°æ®é›†é…ç½®ç®¡ç†
//! - é¡¹ç›®çŠ¶æ€æŒä¹…åŒ–
//!
//! ## ä½¿ç”¨ç¤ºä¾‹
//!
//! ```rust
//! use crate::manager::ProjectManager;
//!
//! let mut manager = ProjectManager::new();
//! let project = manager.open_project("/path/to/project").await?;
//! println!("é¡¹ç›®åç§°: {}", project.name);
//! ```

use std::path::{Path, PathBuf};
use crate::types::{ProjectInfo, PlaybackError, Result};
```

### å‡½æ•°æ–‡æ¡£è§„èŒƒ

```rust
impl ProjectManager {
    /// æ‰“å¼€æŒ‡å®šè·¯å¾„çš„é¡¹ç›®
    ///
    /// æ‰«æé¡¹ç›®ç›®å½•ï¼ŒåŠ è½½é…ç½®æ–‡ä»¶ï¼Œåˆå§‹åŒ–æ•°æ®é›†è¯»å–å™¨ã€‚
    /// å¦‚æœé¡¹ç›®ç›®å½•ä¸å­˜åœ¨PPROJæ–‡ä»¶ï¼Œå°†è‡ªåŠ¨ç”Ÿæˆé»˜è®¤é…ç½®ã€‚
    ///
    /// # å‚æ•°
    ///
    /// * `project_path` - é¡¹ç›®ç›®å½•è·¯å¾„ï¼Œå¿…é¡»æ˜¯æœ‰æ•ˆçš„ç›®å½•
    ///
    /// # è¿”å›å€¼
    ///
    /// * `Ok(ProjectInfo)` - æˆåŠŸåŠ è½½çš„é¡¹ç›®ä¿¡æ¯ï¼ŒåŒ…å«æ‰€æœ‰æ•°æ®é›†é…ç½®
    /// * `Err(PlaybackError)` - åŠ è½½å¤±è´¥çš„å…·ä½“é”™è¯¯ä¿¡æ¯
    ///
    /// # é”™è¯¯
    ///
    /// ä»¥ä¸‹æƒ…å†µä¼šè¿”å›é”™è¯¯ï¼š
    /// - è·¯å¾„ä¸å­˜åœ¨æˆ–ä¸æ˜¯ç›®å½•
    /// - ç¼ºå°‘è¯»å–æƒé™
    /// - PPROJæ–‡ä»¶æ ¼å¼æ— æ•ˆ
    /// - æ•°æ®é›†æ–‡ä»¶æŸåæˆ–ä¸å¯è®¿é—®
    ///
    /// # æ€§èƒ½è¯´æ˜
    ///
    /// - å¤§å‹é¡¹ç›®çš„åŠ è½½æ—¶é—´ä¸æ•°æ®é›†æ•°é‡å’Œæ–‡ä»¶å¤§å°æˆæ­£æ¯”
    /// - ä½¿ç”¨å¼‚æ­¥I/Oé¿å…é˜»å¡ä¸»çº¿ç¨‹
    /// - è‡ªåŠ¨ç¼“å­˜æ–‡ä»¶å…ƒæ•°æ®ä»¥æé«˜åç»­è®¿é—®é€Ÿåº¦
    ///
    /// # ç¤ºä¾‹
    ///
    /// ```rust
    /// use crate::manager::ProjectManager;
    ///
    /// let mut manager = ProjectManager::new();
    ///
    /// match manager.open_project("/data/experiment_001").await {
    ///     Ok(project) => {
    ///         println!("é¡¹ç›®åŠ è½½æˆåŠŸ: {}", project.name);
    ///         println!("åŒ…å« {} ä¸ªæ•°æ®é›†", project.datasets.len());
    ///     }
    ///     Err(e) => {
    ///         eprintln!("é¡¹ç›®åŠ è½½å¤±è´¥: {}", e);
    ///     }
    /// }
    /// ```
    pub async fn open_project<P: AsRef<Path>>(
        &mut self,
        project_path: P
    ) -> Result<ProjectInfo> {
        // å®ç°ç»†èŠ‚...
    }
}
```

## ğŸ”§ å·¥å…·é…ç½®

### Cargo.toml ä¾èµ–è§„èŒƒ

```toml
[package]
name = "playback-engine"
version = "0.1.0"
description = "PCAPæ•°æ®å›æ”¾å¼•æ“"
authors = ["KimoTech"]
edition = "2021"
rust-version = "1.70"

[dependencies]
# Tauri æ ¸å¿ƒä¾èµ–
tauri = { version = "2", features = ["protocol-asset"] }
tauri-plugin-dialog = "2"
tauri-plugin-opener = "2"

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde-xml-rs = "0.6"

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.0", features = ["full"] }

# é”™è¯¯å¤„ç†
thiserror = "1.0"

# æ—¥å¿—ç³»ç»Ÿ
log = "0.4"
env_logger = "0.10"

# æ—¶é—´å¤„ç†
chrono = { version = "0.4", features = ["serde"] }

# åŠ å¯†å’Œå“ˆå¸Œ
sha2 = "0.10"

# æœ¬åœ°pcap-ioåº“
pcap-io = { path = "./crates/pcap-io" }

[dev-dependencies]
tokio-test = "0.4"
tempfile = "3.0"
criterion = "0.5"

[features]
default = []
debug-logging = ["log/max_level_trace"]
```
