---
alwaysApply: true
---
# 系统架构设计原则规范

## 🏗️ 整体架构设计

### Tauri 前后端分离架构

```txt
┌─────────────────────────────────────┐
│    前端表现层 (Nuxt3 + Vue3)        │  ← 用户界面和交互
├─────────────────────────────────────┤
│    命令接口层 (Tauri Commands)      │  ← 前后端通信桥梁
├─────────────────────────────────────┤
│    业务管理层 (Rust Managers)       │  ← 状态管理和业务逻辑
├─────────────────────────────────────┤
│    核心服务层 (Rust Services)       │  ← 数据处理和文件操作
└─────────────────────────────────────┘
```

### 层次职责定义

**前端表现层**: Vue3组件化UI，Composables状态管理，TypeScript类型安全
**命令接口层**: Tauri命令处理，参数验证，错误转换，异步协调
**业务管理层**: 工程管理，播放控制，缓存策略，事件发送
**核心服务层**: PCAP处理，文件I/O，数据解析，系统集成

## 📁 目录组织规范

### 前端结构 (Nuxt3)

```txt
components/          # 组件分层
├── base/            # 基础组件
├── business/        # 业务组件
│   ├── features/    # 功能模块
│   └── layout/      # 布局组件
├── display/         # 展示组件
├── input/           # 输入组件
└── menu/            # 菜单组件

composables/         # 状态管理
├── useProject.ts    # 项目状态
├── useTimeline.ts   # 播放控制
└── use*.ts          # 其他业务逻辑

types/               # 类型定义
├── index.ts         # 导出汇总
└── *.ts             # 分模块类型
```

### 后端结构 (Tauri)

```txt
src/
├── commands/        # 命令接口层
│   ├── project.rs   # 项目操作命令
│   └── *.rs         # 其他命令模块
├── manager/         # 业务管理层
│   ├── project.rs   # 工程管理器
│   └── *.rs         # 其他管理器
├── types/           # 类型定义
└── lib.rs           # 模块声明

crates/              # 独立模块
└── pcapfile-io/         # PCAP处理模块
    ├── api/         # 用户接口层
    ├── business/    # 业务逻辑层
    ├── data/        # 数据访问层
    └── foundation/  # 基础设施层
```

## 🔌 接口设计原则

### Tauri 命令规范

- 使用 `snake_case` 命名命令
- 返回统一的 `Result<T, String>` 类型
- 所有公开命令添加详细文档注释
- 异步操作使用 `async` 标记

### 状态管理规范

**前端**: Composables + reactive data，避免全局状态污染
**后端**: Arc<Mutex\<T>> 或 DashMap 进行线程安全管理
**通信**: 使用 Tauri Events 进行双向数据推送

### 错误处理策略

- 使用 `thiserror` 定义分层错误类型
- 命令层进行错误转换和用户友好化
- 前端显示具体错误信息和恢复建议

## 🚀 性能优化原则

### 数据处理优化

- PCAP文件流式读取，避免全量加载
- 使用索引文件加速随机访问
- 批量操作减少IPC通信开销
- 异步处理避免UI阻塞

### 内存管理策略

- Rust零拷贝操作优化内存使用
- 前端虚拟滚动处理大数据量
- 合理缓存平衡性能和内存占用
- 及时释放不需要的资源

### 并发处理设计

- Rust后端使用Tokio异步运行时
- 多线程处理计算密集型任务
- 前端Web Workers处理复杂计算
- 避免长时间阻塞主线程
