---
alwaysApply: true
---
# ä»£ç é£æ ¼å’Œå·¥ç¨‹å¼€å‘è§„èŒƒ

## ğŸ¨ å‰ç«¯ä»£ç è§„èŒƒ (TypeScript/Vue3)

### å‘½åçº¦å®š

```typescript
// âœ… å˜é‡å’Œå‡½æ•°ï¼šcamelCase
const projectData = ref<ProjectInfo>()
const loadProjectData = async () => {}

// âœ… ç±»å‹å’Œæ¥å£ï¼šPascalCase
interface ProjectInfo {}
type DataStatus = 'loading' | 'ready' | 'error'

// âœ… å¸¸é‡ï¼šUPPER_SNAKE_CASE
const MAX_FILE_SIZE = 1024 * 1024
const API_ENDPOINTS = {
  PROJECT: '/api/project'
} as const

// âœ… ç»„ä»¶æ–‡ä»¶ï¼šPascalCase
HeaderLogo.vue
PanelEventList.vue
```

### Vue3 ç»„ä»¶è§„èŒƒ

```vue
<template>
  <!-- ä½¿ç”¨è¯­ä¹‰åŒ–æ ‡ç­¾å’Œåˆç†çš„å±‚çº§ç»“æ„ -->
  <div class="project-panel">
    <header class="panel-header">
      <h2>{{ title }}</h2>
    </header>
    <main class="panel-content">
      <!-- å†…å®¹åŒºåŸŸ -->
    </main>
  </div>
</template>

<script setup lang="ts">
// âœ… å¯¼å…¥é¡ºåºï¼šVue -> ç¬¬ä¸‰æ–¹ -> æœ¬åœ°
import { ref, computed, onMounted } from 'vue'
import { invoke } from '@tauri-apps/api'
import { useProject } from '~/composables/useProject'

// âœ… æ¥å£å®šä¹‰åœ¨ç»„ä»¶å†…éƒ¨æˆ–å•ç‹¬æ–‡ä»¶
interface Props {
  title: string
  projectId?: string
}

// âœ… ä½¿ç”¨ defineProps å’Œ defineEmits
const props = withDefaults(defineProps<Props>(), {
  projectId: ''
})

const emit = defineEmits<{
  projectLoaded: [project: ProjectInfo]
}>()

// âœ… å“åº”å¼æ•°æ®ä½¿ç”¨ç±»å‹æ³¨è§£
const isLoading = ref<boolean>(false)
const project = ref<ProjectInfo | null>(null)

// âœ… è®¡ç®—å±æ€§æ˜ç¡®è¿”å›ç±»å‹
const displayTitle = computed((): string => {
  return props.title || 'é»˜è®¤æ ‡é¢˜'
})
</script>

<style scoped>
/* âœ… ä½¿ç”¨ TailwindCSSï¼Œé¿å…è‡ªå®šä¹‰æ ·å¼ */
.project-panel {
  @apply flex flex-col bg-white rounded-lg shadow-md;
}

.panel-header {
  @apply px-4 py-3 border-b border-gray-200;
}

/* âœ… å¿…è¦æ—¶ä½¿ç”¨ CSS å˜é‡ */
.custom-component {
  --primary-color: #3b82f6;
  --border-radius: 0.5rem;
}
</style>
```

### Composables è§„èŒƒ

```typescript
// composables/useProject.ts
export function useProject() {
  // âœ… å†…éƒ¨çŠ¶æ€ä½¿ç”¨ ref æˆ– reactive
  const projectInfo = ref<ProjectInfo | null>(null)
  const isLoading = ref(false)
  const error = ref<string | null>(null)

  // âœ… å¼‚æ­¥æ“ä½œä½¿ç”¨ async/await
  const loadProject = async (projectPath: string): Promise<void> => {
    try {
      isLoading.value = true
      error.value = null

      const result = await invoke<ProjectInfo>('load_project', {
        path: projectPath
      })

      projectInfo.value = result
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'åŠ è½½é¡¹ç›®å¤±è´¥'
      console.error('åŠ è½½é¡¹ç›®å¤±è´¥:', err)
    } finally {
      isLoading.value = false
    }
  }

  // âœ… è¿”å›åªè¯»çŠ¶æ€å’Œæ“ä½œæ–¹æ³•
  return {
    // åªè¯»çŠ¶æ€
    projectInfo: readonly(projectInfo),
    isLoading: readonly(isLoading),
    error: readonly(error),

    // æ“ä½œæ–¹æ³•
    loadProject,
    clearProject: () => {
      projectInfo.value = null
      error.value = null
    }
  }
}
```

## ğŸ¦€ åç«¯ä»£ç è§„èŒƒ (Rust)

### å‘½åçº¦å®š

```rust
// âœ… ç»“æ„ä½“å’Œæšä¸¾ï¼šPascalCase
pub struct ProjectManager {}
pub enum DataStatus { Loading, Ready, Error }

// âœ… å‡½æ•°å’Œå˜é‡ï¼šsnake_case
pub fn load_project_data() -> Result<()> {}
let file_path = PathBuf::new();

// âœ… å¸¸é‡ï¼šUPPER_SNAKE_CASE
pub const MAX_BUFFER_SIZE: usize = 8192;
const DEFAULT_TIMEOUT: Duration = Duration::from_secs(30);

// âœ… æ¨¡å—ï¼šsnake_case
mod project_manager;
mod data_processor;
```

### é”™è¯¯å¤„ç†è§„èŒƒ

```rust
use thiserror::Error;

// âœ… ç»Ÿä¸€é”™è¯¯ç±»å‹å®šä¹‰
#[derive(Error, Debug)]
pub enum AppError {
    #[error("é¡¹ç›®åŠ è½½å¤±è´¥: {path}")]
    ProjectLoadFailed { path: String },

    #[error("æ–‡ä»¶æ“ä½œé”™è¯¯: {source}")]
    FileError {
        #[from]
        source: std::io::Error
    },

    #[error("æ•°æ®è§£æé”™è¯¯: {message}")]
    ParseError { message: String },
}

pub type Result<T> = std::result::Result<T, AppError>;

// âœ… å‘½ä»¤å±‚é”™è¯¯è½¬æ¢
#[tauri::command]
pub async fn load_project(path: String) -> Result<ProjectInfo, String> {
    project_manager::load_project(&path)
        .await
        .map_err(|e| e.to_string())
}
```

### æ–‡æ¡£æ³¨é‡Šè§„èŒƒ

```rust
/// å·¥ç¨‹ç®¡ç†å™¨
///
/// è´Ÿè´£é¡¹ç›®çš„åŠ è½½ã€ä¿å­˜å’ŒçŠ¶æ€ç®¡ç†ã€‚æ”¯æŒå¤šç§é¡¹ç›®æ ¼å¼ï¼Œ
/// æä¾›å¼‚æ­¥æ“ä½œæ¥å£ã€‚
///
/// # ç¤ºä¾‹
/// ```rust
/// use crate::manager::ProjectManager;
///
/// let manager = ProjectManager::new();
/// let project = manager.load_project("/path/to/project").await?;
/// ```
pub struct ProjectManager {
    /// å½“å‰é¡¹ç›®ä¿¡æ¯
    current_project: Option<ProjectInfo>,
    /// é¡¹ç›®ç¼“å­˜
    cache: DashMap<String, ProjectInfo>,
}

impl ProjectManager {
    /// åŠ è½½æŒ‡å®šè·¯å¾„çš„é¡¹ç›®
    ///
    /// # å‚æ•°
    /// * `path` - é¡¹ç›®æ–‡ä»¶æˆ–ç›®å½•è·¯å¾„
    ///
    /// # è¿”å›å€¼
    /// * `Ok(ProjectInfo)` - æˆåŠŸåŠ è½½çš„é¡¹ç›®ä¿¡æ¯
    /// * `Err(AppError)` - åŠ è½½å¤±è´¥çš„é”™è¯¯ä¿¡æ¯
    ///
    /// # é”™è¯¯
    /// å½“è·¯å¾„ä¸å­˜åœ¨æˆ–æ ¼å¼ä¸æ­£ç¡®æ—¶è¿”å›é”™è¯¯
    pub async fn load_project<P: AsRef<Path>>(&mut self, path: P) -> Result<ProjectInfo> {
        // å®ç°é€»è¾‘...
    }
}
```

### å¼‚æ­¥ç¼–ç¨‹è§„èŒƒ

```rust
// âœ… ä½¿ç”¨ async/await è¿›è¡Œå¼‚æ­¥ç¼–ç¨‹
#[tauri::command]
pub async fn process_large_dataset(
    dataset_path: String,
    options: ProcessOptions
) -> Result<ProcessResult, String> {
    tokio::task::spawn_blocking(move || {
        // CPU å¯†é›†å‹ä»»åŠ¡åœ¨çº¿ç¨‹æ± ä¸­æ‰§è¡Œ
        heavy_computation(&dataset_path, &options)
    })
    .await
    .map_err(|e| format!("ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {}", e))?
    .map_err(|e| e.to_string())
}

// âœ… æ­£ç¡®ä½¿ç”¨ Arc å’Œ Mutex è¿›è¡ŒçŠ¶æ€å…±äº«
pub struct AppState {
    pub project_manager: Arc<Mutex<ProjectManager>>,
    pub cache: Arc<DashMap<String, CachedData>>,
}

impl AppState {
    pub async fn get_project(&self) -> Option<ProjectInfo> {
        let manager = self.project_manager.lock().await;
        manager.current_project.clone()
    }
}
```

## ğŸ“ æ³¨é‡Šå’Œæ–‡æ¡£è§„èŒƒ

### æ³¨é‡ŠåŸåˆ™

```typescript
// âœ… è§£é‡Šä¸ºä»€ä¹ˆï¼Œè€Œä¸æ˜¯åšä»€ä¹ˆ
// ç”±äº Tauri çš„é™åˆ¶ï¼Œéœ€è¦åºåˆ—åŒ–å¤§å¯¹è±¡æ—¶ä½¿ç”¨åˆ†ç‰‡ä¼ è¾“
const chunks = splitIntoChunks(largeData, CHUNK_SIZE)

// âœ… å¤æ‚ä¸šåŠ¡é€»è¾‘æ·»åŠ è¯´æ˜
// æ’­æ”¾é€Ÿåº¦è®¡ç®—ï¼šåŸºç¡€é€Ÿåº¦ * ç”¨æˆ·å€é€Ÿè®¾ç½® * æ€§èƒ½è°ƒèŠ‚å› å­
const actualSpeed = baseSpeed * userSpeedMultiplier * performanceFactor
```

```rust
// âœ… é‡è¦ç®—æ³•æ·»åŠ è¯¦ç»†è¯´æ˜
/// ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾å®šä½æ—¶é—´æˆ³å¯¹åº”çš„æ•°æ®åŒ…ä½ç½®
///
/// æ—¶é—´å¤æ‚åº¦ï¼šO(log n)
/// ç©ºé—´å¤æ‚åº¦ï¼šO(1)
fn find_packet_by_timestamp(&self, timestamp: u64) -> Option<usize> {
    // å®ç°ç»†èŠ‚...
}
```

## ğŸ”§ å·¥å…·é…ç½®

### ESLint é…ç½®ç²¾ç®€ç‰ˆ

```javascript
// eslint.config.mjs
export default [
  {
    rules: {
      // TypeScript è§„åˆ™
      '@typescript-eslint/no-unused-vars': 'error',
      '@typescript-eslint/explicit-function-return-type': 'warn',

      // Vue è§„åˆ™
      'vue/component-name-in-template-casing': ['error', 'PascalCase'],
      'vue/component-definition-name-casing': ['error', 'PascalCase'],

      // é€šç”¨è§„åˆ™
      'no-console': 'warn',
      'prefer-const': 'error'
    }
  }
]
```

### Prettier é…ç½®

```json
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "none",
  "printWidth": 80,
  "endOfLine": "lf"
}
```
